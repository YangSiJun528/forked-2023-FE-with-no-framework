# 7장. 상태 관리

상태 관리란 무엇인지 알아보고 3가지 상태 관리 전략에 대해 알아보고 비교해보자.

## 1. 상태 관리란?

웹, 데스크톱, 모바일 등 모든 종류의 프론트엔드 애플리케이션의 효과적인 데이터 관리 방법을 **상태 관리**(state management)라고 한다.

리액트가 주류 라이브러리가 되면서 유명한 상태 관리 패턴인 **MVC(모델-뷰-컨트롤러) 패턴**이 알려지게 되었고, 프레임워크에 종속적인 Vuex, NgRx 라이브러리부터 프레임워크에 관계없이 자유롭게 사용할 수 있는 Mobx, Redux 라이브러리까지 여러 **프레임워크 상태 관리용 라이브러리**가 등장하게 되었다.

상태 관리 코드에 적합한 아키텍처의 선택은 애플리케이션을 건강하게 유지 관리하는 데 중요하다.

## 2. 3가지 상태 관리 전략

### 2.1 MVC

MVC(Model-View-Controller)에서는 애플리케이션의 상태를 컨트롤러가 아닌 외부 모델에서 관리하도록 한다.

렌더링에 사용된 실제 데이터는 model 객체의 `getState` 메서드에서 반환된다. 이때 반환된 값은 불변(immutable)이다. 불변 상태를 이용해 데이터를 전송하면 이 API의 소비자는 상태를 조작하는 데 공개 메서드를 사용해야 한다.

```js
const getState = () => {
  return Object.freeze(cloneDeep(state)); // state의 복사본을 생성한 후 Object.freeze로 고정한다.
};
```

MVC 패턴에서는 비즈니스 로직이 Model 객체에 완전히 포함되도록 한다. 이 방식은 상태 관리 코드를 코드베이스 수명기간 동안 **높은 수준의 테스트 가능성**으로 유지하는 데 도움이 된다.

MVC 패턴을 사용했을 때 **애플리케이션의 워크플로우와 구성 요소들의 관계**를 살펴보자.

<img src="https://user-images.githubusercontent.com/67703882/219944655-2f4e82e8-7b4a-4e32-bb0c-618a6b8340e5.jpeg" alt="IMG_FB6C168FC9BA-1" style="zoom:40%;" />

1. 컨트롤러는 모델에서 초기 상태를 가져오고, 뷰를 호출해 초기 상태를 렌더링한다.
2. 사용자 입력을 받을 준비를 한 이후, 시스템이 특정 동작을 수행한다. (ex. 항목 추가)
3. 컨트롤러는 올바른 Model 메서드(ex. `model.addItem`)로 사용자의 동작과 매핑한다.
4. 모델은 상태를 업데이트하면, 컨트롤러는 모델에서 새로운 상태를 얻는다.
5. 컨트롤러는 뷰를 호출해 새로운 상태를 렌더링한다.
6. 시스템은 다시 사용자 입력을 받을 준비가 됐다.

위 워크플로우를 요약하자면 다음 그림과 같다.

<img width="970" alt="스크린샷 2023-02-20 16 00 57" src="https://user-images.githubusercontent.com/67703882/220035307-12340797-34dd-4af0-9a65-037ce7a8db65.png" style="zoom:60%;" >

여기서 렌더링과 사용자 동작 사이의 루프를 '렌더링 주기' 라고 한다.

### 2.1.1 옵저버블 모델

MVC 기반으로 작성한 상태 관리 코드는 사용자가 동작을 수행할 때마다 `render` 메서드를 수동으로 호출하므로 모델과 컨트롤러 간의 통합이 완벽하지 않다. 이러한 방식이 최적의 솔루션이 아닌 2가지 이유는 다음과 같다.

- 상태 변경 후 렌더링을 수동으로 호출하는 방식은 오류가 발생하기 쉬운 접근 방식이다.

- 동작이 상태를 변경하지 않을 때에도 `render` 메서드가 호출된다. (ex. 빈 항목을 리스트에 추가)

이러한 문제를 **옵저버블 패턴**(observer pattern)을 기반으로 하는 모델을 통해 해결할 수 있다.

옵저버블 패턴을 사용하면 model 객체에서 상태를 얻는 유일한 방법은 리스너 콜백 추가(`addChangeListener`)이다. 해당 콜백은 가입할 때와 내부 상태가 변경될 때마다 호출이 된다.

해당 모델을 통해 컨트롤러를 단순화할 수 있다. 컨트롤러에서 이벤트를 구현하는게 아닌, model 객체에서 메서드들을 추출하여 이들을 이벤트로 사용한다. 이 모델은 공개 인터페이스를 수정하지 않고 컨트롤러에 새로운 기능을 추가 하는 데에도 유용하다.

> 예시 코드 파일 중 `03.todo-observer-pattern-listeners` 의 컨트롤러 코드를 보면 간단한 로거(logger)와 상태를 localStorage에 저장하는 함수를 변경 리스너로 추가한 것을 확인할 수 있다.

따라서 컨트롤러가 모델과 밀접하게 결합된다면 옵저버블 패턴을 고려하는 것이 좋다.

### 2.2 반응형 프로그래밍

**반응형 프로그래밍**(Reactive Programming)이란 애플리케이션이 모델 변경, HTTP 요청, 사용자 동작, 탐색 등과 같은 이벤트를 방출할 수 있는 옵저버블로 동작하도록 구현하는 것을 의미한다. 이는 앵귤러 프레임워크가 RxJS를 기반으로 하고 있다는 것이 알려지면서 인기를 끌기 시작했다.

> 반응형 프로그래밍 관련 글
>
> - [안드레 스탈츠(RxJS 관리자)의 반응형 프로그래밍 소개](https://gist.github.com/staltz/868e7e9bc2a7b8c1f754)
> - [루카 메차리라의 Front-End Reactive Architectures(프론트엔드 반응형 아키텍처)](https://books.google.co.kr/books?id=lxBlswEACAAJ&dq=front-end+reactive+architectures&hl=en&sa=X&redir_esc=y)

반응형 상태 관리 아키텍처를 설계하는 좋은 방법은 간단한 옵저버블 모델을 생성하는 것이다. 우리는 둘 이상의 Model 객체가 필요할 때 **옵저버블 팩토리 추상화**를 생성할 수 있다. (이 역시 3장에서 소개한 [YAGNI 원칙](https://github.com/gdsc-ssu/2023-FE-with-no-framework/tree/main/03.%20DOM%20%EC%9D%B4%EB%B2%A4%ED%8A%B8%20%EA%B4%80%EB%A6%AC#-yagni-%EC%9B%90%EC%B9%99)의 예가 될 수 있다.)

```js
// observer.js
...
const baseProxy = {  addChangeListener,  };
return Object.keys(model)
  .filter((key) => {
    return typeof model[key] === 'function';
  })
  .reduce((proxy, key) => {
    const action = model[key];
    return { ...proxy, [key]: wrapAction(action) }; // wrapAction은 리스너를 호출하는 동일한 action을 반환한다.
  }, baseProxy);
```

옵저버블 팩토리에서는 model 객체의 원본 메서드를 래핑하고 리스너를 호출하는 동일한 이름의 새 메서드를 생성한다. 또 프록시로 상태를 전달하고자 간단한 getter 함수를 사용해 모델에서 변경이 수행될 때마다 현재 state를 가져오도록 한다.

아래의 그림을 통해 컨트롤러와 모델, 프록시 간의 관계를 보여준다.

<img width="279" alt="스크린샷 2023-02-20 16 01 15" src="https://user-images.githubusercontent.com/67703882/220035348-22b9a681-9071-429d-aba2-403524493c45.png" style="zoom:80%;" >

### 2.2.1 네이티브 프록시

자바스크립트는 [Proxy 객체](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy)를 통해 프록시를 생성할 수 있는 방법을 제공한다. 이 API를 통해 객체의 디폴트 동작을 사용자 정의 코드로 쉽게 매핑할 수 있다.

```js
const base = { foo: 'bar' };

// 프록시를 생성하려면 트랩 집합으로 구성된 핸들러가 필요하다. (게터와 세터)
const handler = {
  get: (target, name) => {
    return target[name];
  },
  set: (target, name, value) => {
    target[name] = value;
    return true;
  },
};
// Proxy API 사용
const proxy = new Proxy(base, handler);
proxy.foo = 'baz'; // proxy = { foo:'baz'};
```

예시 코드 파일 중 `05.todo-observable-factory-proxy` 를 보면 **Proxy 객체**를 통해 옵저버블 팩토리를 생성한다. 이때 Proxy 객체를 사용할 때 set 트랩을 호출하려면 state를 수정하는 대신 새롭게 교체해야 한다. 예를 들어 `addItem` 메서드에서 todos 배열에 `push` 메서드를 사용해서 요소를 추가하는 것이 아니라, 새로운 todos 배열로 덮어쓰는 것을 볼 수 있다.

### 2.3 이벤트 버스

**이벤트 버스**(event bus) 은 이벤트 주도 아키텍처(EDA, Event-Driven Architecture)를 구현하는 방법 중 하나이다.

> **EDA**(Event-Driven Architecture)란?
> 분산된 시스템에서 이벤트를 생성(발행)하고 발행된 이벤트를 수신자에게 전송하면 수신자는 해당 이벤트를 처리하는 방식의 아키텍처이다. 분산 아키텍처 환경에서 상호 간 결합도를 낮추기 위해 비동기 방식으로 메세지를 전달하는 패턴으로 주로 Message Broker(ex. Kafka)와 결합하여 구성된다.

이벤트는 발생한 상황을 식별하는 '이름'과 이벤트 처리를 위해 의미 있는 정보를 담고 있는 'payload' 로 정의된다.

```
const event = {
	type : 'ITEM_ADDED',
	payload : 'Buy Milk'
}
```

이벤트 버스 패턴에서는 애플리케이션을 구성하는 '노드'들을 연결하는 단일 객체가 모든 이벤트를 처리한다. 이벤트가 처리되면 결과가 연결된 모든 노드로 전송된다.

`ITEM_ADDED` 이벤트가 발생했을 때 이벤트 버스의 동작 방식을 이해해보자.

<img src="https://user-images.githubusercontent.com/67703882/220047171-6fe6e177-eec1-42f0-b813-dc0eda80f654.jpeg" alt="IMG_59C9AA141043-1" style="zoom:30%;" />

1. 뷰는 초기 상태를 렌더링한다.
2. 사용자가 폼을 작성하고 엔터키를 누른다.
3. DOM 이벤트가 뷰에 의해 캡처되면, 뷰는 `ITEM_ADDED` 이벤트를 생성하고 버스로 보낸다.
4. 버스는 새로운 상태를 생성하는 이벤트를 처리한다.
5. 새로운 상태가 컨트롤러에 전송되면, 컨트롤러는 뷰를 호출해 새로운 상태를 렌더링한다.
6. 시스템은 다시 사용자 입력을 받을 준비가 됐다.

여기서 한가지 잘못된 점이 있다. 위 방식에서 '버스는 새로운 상태를 생성하는 이벤트를 처리한다' 라고 했지만, 이벤트 버스는 아키텍처적인 요소이기 때문에 도메인 관련 코드를 포함해서는 안된다. 따라서 이벤트 버스 패턴을 구현하려면 모델을 믹스(mix)에 추가해야 한다.

<img src="https://user-images.githubusercontent.com/67703882/220049151-571c2d3f-5afb-484c-aa42-4fbac56fc40e.jpeg" alt="IMG_9F57D7A1EE74-1" style="zoom:30%;" />

이 책에서는 이벤트 버스 구현을 2가지 방식으로 구현한다. 첫번째 방식은 프레임워크 없이 작성하고, 두번째 방식은 Redux를 기반으로 한다.

### 2.3.1 프레임워크 없는 구현

`06. todo-eventbus-no-framework` 의 코드를 보면, 모델이 입력으로 이전 상태와 이벤트를 받아 새로운 상태를 반환하는 **순수 함수** 임을 알 수 있다. 순수 함수로 모델을 설계하면 새로운 상태가 모델 자체의 내부 상태가 되므로 테스트 가능성을 향상시키고, 상태가 업데이트되면 항상 새로운 객체가 되므로 이를 이용해 성능을 최적화할 수 있다.

실제 애플리케이션에서는 코드 가독성을 위해 모델 함수를 작은 서브모델로 분할한다. `07. todo-eventbus-no-framework-sub-model` 를 보면 todo, filter를 각각 관리하는 2개의 서브 모델이 있고, 메인 model 함수가 서브모델의 결과를 하나의 state 객체로 병합하는 것을 알 수 있다.

### 2.3.2 Redux

**Redux**는 Dan Abramov가 2015년에 처음 발표한 이후, 리액트 애플리케이션 제작의 주류 방식이 된 상태 관리 라이브러리이다. Redux를 사용하는 방식은 프레임워크 없이 구현한 이벤트 버스와 용어는 다를 뿐 방식은 매우 비슷하다.

|      이벤트 버스       |      Redux      |
| :--------------------: | :-------------: |
| 이벤트 버스(event bus) |  스토어(store)  |
|     이벤트(event)      |  액션(action)   |
|      모델(model)       | 리듀서(reducer) |

> [Redux의 3가지 기본 원칙](https://redux.js.org/understanding/thinking-in-redux/three-principles)
>
> - 애플리케이션의 모든 state는 하나의 store 안에 하나의 객체 트리 구조로 저장된다.
> - state를 변화시키려면 어떤 일을 해야할지를 묘사하는 action 객체를 전달해야한다.
> - action에 의해 상태 트리가 어떻게 변화하는지 지정하기 위해 순수 reducer를 작성해야한다.

Redux를 사용하게 되면 'Redux DevTools' 같이 편리한 도구와 플러그인을 사용할 수 있다. Redux DevTools는 시스템의 모든 작업을 쉽게 기록하고 상태에 미치는 영향을 확인할 수 있도록 해주고, JSON 형태로 상태를 가져오거나 내보낼 수 있도록 해준다.

## 3. 상태 관리 전략 비교 분석

마지막으로 3가지의 상태 관리 전략의 장단점을 알아보고 비교해보자.

### 3.1 MVC

#### 장점

- 구현하기 매우 간단하다.
- 비즈니스 로직에 대한 테스트 가능성과 관심 분리 같은 이점을 제공한다.

#### **단점**

- 엄격한 패턴이 아니므로 요소의 정의와 그 사이의 관계가 불분명할 수 있다. 이러한 불분명한 영역을 효과적으로 작업하기 위해서 팀의 MVC 규칙을 정의해야한다.
- 이러한 불분명한 영역은 애플리케이션이 커질수록 증가하므로, 확장성 문제도 발생한다.

### 3.2 반응형 프로그래밍

#### 장점

- 옵저버블한 모델을 이용한 방식은 '동일한 타입'의 객체로 작업하기 때문에 일관성을 보장한다.

#### 단점

- 모든 옵저버블을 래핑하는 것은 간단하지가 않다. RxJS 같은 서드파티 라이브러리를 사용하는 것이 도움이 될 수 있으나 여전히 간단하지는 않다.
- 중앙 추상화를 기반으로 작업한다. 이로 인해 애플리케이션이 '누설'될 수 있다.

> [**Leak Abstraction**의 법칙](https://www.joelonsoftware.com/2002/11/11/the-law-of-leaky-abstractions/)
>
> 추상화는 고수준의 기능을 빠르고 편리하게 사용할 수 있도록 도와주지만, 잘못된 추상화의 구현으로 인해 이를 고치는 비용이 증가하는 것을 의미한다.

### 3.3 이벤트 버스

#### 장점

- '모든 상태 변경은 이벤트에 의해 생성된다' 라는 엄격한 규칙을 기반으로 한다. 이로 인해 애플리케이션의 복잡성을 애플리케이션의 크기와 비례해도록 유지할 수 있다. (코드 베이스의 확장성)
- 이벤트 버스는 사용하기 쉽고 구축도 쉽다. 추상화가 반응형 프로그래밍에 비해 강하지 않아 비교적 단순하다.

#### 단점

- 모든 상태 업데이트에 대해 이벤트 생성, 이벤트 발송, 업데이트 모델 생성, 리스너 전송 작업을 모두 처리해야 하므로 '다변성(verbosity)' 문제를 가지고 있다.
- 간단한 도메인 관리를 위해 다른 상태 관리 전략을 함께 사용하게 되면 일관성이 떨어질 수 있다.

### 3.4 상태 관리 전략 비교

<img width="646" alt="스크린샷 2023-02-20 19 17 16" src="https://user-images.githubusercontent.com/67703882/220077601-c6891fd3-d645-4e1b-a545-427c6f42ca78.png" style="zoom:80%;" >
